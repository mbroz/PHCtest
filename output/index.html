<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title>Trivial PHC candidates tests</title>
</head>
<style>@media print { h2 {page-break-before:always} }</style>
<body>
<h1>Trivial PHC candidates parameters vizualization/test (using provided API)</h1>

<p>All PHC candidates provide API function</p>
<pre>
int PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost); 
</pre>

<p>The following tests tries to do some simple operations using this
provided function.</p>

<p>The candidate functions do not implement the API parameters
consistently.<br>Some functions implement only one of the cost
parameters (memory or time) and the scale differs significantly.
</p>
<p>The following tests take the password hash function as a
black-box,<br>supposing that invalid or unsupported parameters
combination is detected and function returns an error.<br>
(Which is not always true, unfortunately.)
</p>
<p>The tests always use one input parameter as a variable and
measure run time and/or memory consumption.</p>

<h3>Test vectors</h3>
I tried to reuse generated test vectors (including format) from previous test
run by Bill Cox,<br>
unfortunately not all files are usable (there are some modifications in algorithms<br>
and some vectors are not correct.)<br>
The included test script is in root directory, see run_vectors script.


<h3>Test description</h3>
<p>All test uses special utility which measures difference in used memory using
<i>getrusage()</i> system call and<br>
run time using <i>clock_gettime(CLOCK_MONOTONIC)</i>.</p>
<p>The test run as special forked process started for each test separately.</p>
<p>The tests are repeated for 3 times and arithmetic mean of measurements is used.</p>

<p>Because most of the algoritmhs are in reference source without
optimization, performance comparisons does not make much sense.</p>
<p>The intention of tests it to compare limits and generic behaviour of algorithms.</p>

<h3>Code repository</h3>
<p>The repository copies submitted source code of PHC algoritms and compiles static library
for each algorithm.</p>
<p>All changes to submitted code are tracked by quilt, see <i>patches</i> subdirectory
in git (separate for every algorithm).
<br>(Changes includes only makefile modification for library build fixes, if neccessary.)</p>

<p>All code and output is on GitHub - <a href="https://github.com/mbroz/PHCtest">https://github.com/mbroz/PHCtest</a>.</p>
<h3>Algorithms</h3>
<p>Included are all submitted algoritms, except PolyPassHash (cannot be tested this way).</p>
<p>Added also Catena2 and RIG2 as were sent to mailing list.</p>
<p>Algorithms are in default (if possible reference) configurations. See source code for more details.</p>
<p>Graphs are generated by Gnuplot automatically, see source code.
<hr>
<h1>Example output: Lenovo X230 / i5 CPU / 4GB memory</h1>

<h3>Internal / detected algorithm limits:</h3>
Some algorithms do have strict limits but not all returns proper error on PHS() call.<br>
The following table is partial list of limits which were detected in these tests.<br>
<pre>
            plen min plen max out len min out len max mcost min mcost max tcost min tcost max
           |        |        |           |           |         |         |         |         |
Antcrypt   |        |  239   |           |           |         |         |         |         |
Argon      |   0    |  256   |           |    32     |     1   |  1<<26  |    1    |         |
battcrypt  |        |        |           |    64     |         |         |         |         |
Catena     |        |        |           |    64     |   18    |   63    |         |         |
Catena2-BRG|        |        |           |    64     |         |         |         |         |
Catena2-DBG|        |        |           |    64     |         |         |         |         |
Centrifuge |        |        |           |           |         |   63    |         |   63    |
EARWORM    |        |        |           |           |         |         |         |         |
Gambit     |        |  151   |           |           |         |         |         |         |
Lanarea    |   1    |        |      mult 32          |    1    |         |    1    |         |
Lyra2      |        |        |           |           |         |         |    4    |         |
Makwa      |        |        |           |           |         |         |         |         |
MCS_PHS    |        | 238    |     4     |    64     |         |         |         |         |
OmegaCrypt |        | 255    |      16,20,28,32,64   |         |         |         |         |
Parallel   |        |        |           |    64     |         |126 << 16|         |  106    |
POMELO     |        |        |           |   128     |         |         |         |         |
Pufferfish |        |   ?    |           |     ?     |         |         |         |         |
RIG        |        |        |           |   64      |         |         |         |         |
RIG2       |        |        |           |   64      |         |         |         |         |
Schvrch    |        |        |           |           |         |         |         |         |
Tortuga    |        |        |           |           |         |         |         |         |
TwoCats    |        |        |    32     |    32     |         |         |         |         |
Yarn       |        |        |           |    64     |         |         |         |         |
yescrypt   |        |        |    32     |    32     |         |         |         |         |
</pre>

<h2>Test 1. Variable memory cost (and impact to run time and memory use)</h2>
<p>The goal is to verify and compare real used memory according
to memory cost parameter.<br>
Test also compares impact to run time (large used memory accesses are
expensive).</p>
<p>Test increases mcost according to following table and measures used memory and run time.</p>
<p>Other parameters are fixed as below.</p>
<pre>
salt 16 bytes
input 32 bytes
output 32 bytes

           |mcost_min|mcost_step|mcost_max|tcost|
antcrypt   |   0     |     1    |     17  |   0 |
argon      |   0     |   100    |   8000  |   0 |
battcrypt  |   0     |     1    |     16  |   0 |
catena     |   0     |     1    |     25  |   0 |
catena2-dbg|   0     |     1    |     25  |   0 |
catena2-brg|   0     |     1    |     25  |   0 |
centrifuge |   0     |     1    |     23  |   0 |
earworm    |   0     |     1    |     19  |   1 |
gambit     | N/A - cost/memory dependent        |
lanarea    |   0     |    10    |    300  |   1 |
lyra2      |   0     |   200    |  10000  |   1 |
makwa      | N/A -  mcost unused                |
mcs_phs    | N/A - cost/memory dependent        |
omegacrypt |   0     |     1    |     11  |   0 |
parallel   | N/A -  mcost unused                |
pomelo     |   0     |     1    |     17  |   0 |
pufferfish |   0     |     1    |     15  |   0 |
rig        |   0     |     1    |     17  |   1 |
rig2       |   0     |     1    |     17  |   1 |
schvrch    |   0     |  1000    |  50000  |   0 |
tortuga    |   0     | 10000    |1048575  |   0 |
twocats    |   0     |     1    |     20  |   0 |
yarn       |   0     |     1    |     25  |   0 |
yescrypt   |   0     |     1    |     20  |   0 |
</pre>

<p>
<img src="Lenovo_X230_i5_4G/m_cost/mcost_memory.png" border="0">
</p>

<p>
<img src="Lenovo_X230_i5_4G/m_cost/mcost_time.png" border="0">
<br><br><i>Figure 2: Test 1 – Variable memory cost (impact to run time)</i>
</p>

<h2>Test 2. Variable time cost (and impact to run time and memory use)</h2>
<p>The goal is to verify and compare run time according to time cost parameter.<br>
Test also compares impact to used memory (in theory there shouldn't be
significant increase).</p>

<p>Test increases tcost according to following table and measures used memory and run time.</p>
<p>Other parameters are fixed as below.</p>
<pre>
salt 16 bytes
input 32 bytes
output 32 bytes

           |tcost_min|tcost_step|tcost_max| mcost |
antcrypt   |   0     |     1    |      30 |    10 |
argon      |   0     |    10    |     300 |   500 |
battcrypt  |   0     |     1    |      20 |     5 |
catena     |   0     |     5    |     100 |    18 |
catena2-brg|   0     |     5    |     100 |    14 |
catena2-dbg|   0     |     5    |     100 |    14 |
centrifuge |   0     |     1    |      28 |     0 |
earworm    |   0     |   500    |   20000 |    10 |
gambit     | N/A - cost/memory dependent          |
lanarea    |   0     |     1    |       8 |   150 |
lyra2      |   0     |  1000    |   20000 |   100 |
makwa      |   0     | 10000    |  300000 |     0 |
mcs_phs    | N/A - cost/memory dependent          |
omegacrypt |   0     |     1    |       9 |     2 |
parallel   |   0     |     1    |      26 |     0 |
pomelo     |   0     |     1    |      15 |     5 |
pufferfish |   0     |     1    |       9 |    10 |
rig        |   0     |  1000    |   20000 |     5 |
rig2       |   0     |  1000    |   20000 |     5 |
schvrch    |   0     |  2000    |  200000 |  1000 |
tortuga    |   0     | 10000    | 1048575 |100000 |
twocats    |   0     |     1    |      20 |     7 |
yarn       |   0     |100000    |10000000 |    15 |
yescrypt   |   0     |    10    |     300 |    10 |
</pre>

<p>
<img src="Lenovo_X230_i5_4G/t_cost/tcost_memory.png" border="0">
<br><br><i>Figure 3: Test 2 –  Variable time cost (impact to memory use)</i>
</p>

<p>
<img src="Lenovo_X230_i5_4G/t_cost/tcost_time.png" border="0">
<br><br><i>Figure 4: Test 2 –  Variable time cost (impact to run time)</i>
</p>

<h2>Test 3. Impact of input length to run time (with fixed costs parameters).</h2>
<p>The test should illustrate that run time is not dependent on input length.</p>

<p>The input is random password increased from 1 to 300 bytes.</p>
<p>Other parameters are fixed as below (mcost and tcost chosen to be minimal,
just to provide run time aroung 50ms on the particular machine).</p>
<pre>
salt 16 bytes
output 32 bytes
input 1 - 300, step 1 bytes

           | mcost| tcost|
antcrypt   |    0 |   800|
argon      |    0 |  2000|
battcrypt  |    0 |    17|
catena     |   18 |     0|
catena2-brg|   14 |    10|
catena2-dbg|   10 |    10|
centrifuge |    0 |    21|
earworm    |    0 |  1000|
gambit     |30001 | 30001|
lanarea    |    1 |   600|
lyra2      |    3 | 10000|
makwa      |    0 | 30000|
mcs_phs    |    0 | 30000|
omegacrypt |    0 |     1|
parallel   |    0 |    11|
pomelo     |    0 |    13|
pufferfish |    0 |    12|
rig        |    1 |500000|
rig2       |    1 |  3000|
schvrch    |    0 | 12000|
tortuga    |    0 | 80000|
twocats    |    7 |    12|
yarn       |    0 |500000|
yescrypt   |   10 |    10|
</pre>

<h4>Notes</h4>
<pre>
argon - input limit is 255 but API do not produce error on > 255 input (returning still the same hash)
pufferfish - returns still the same hash (broken?)
</pre>
<p>
<img src="Lenovo_X230_i5_4G/i_len/ilen_time.png" border="0">
<br><br><i>Figure 5: Test 3 –  Impact of input length to run time</i>
</p>

<h2>Test 4. Impact of output lengths to run time (with fixed costs parameters).</h2>
<p>The test should illustrate that run time is not dependent on output length.</p>

<p>The output is increased from 1 to 300 bytes.</p>
<p>Other parameters are fixed as below (mcost and tcost chosen to be minimal,
just to provide run time aroung 50ms on the particular machine).</p>

<pre>
salt 16 bytes
intput 32 bytes
output 1 - 300, step 1 bytes

mcost and tcose - same as in previous test
</pre>

<h4>Notes</h4>
<pre>
argon - returning wrong hash for o_len > 32
catena - returning wrong hash for o_len > 256
catena2-brg - returning wrong hash for o_len > 256
catena2-dbg - returning wrong hash for o_len > 256
yescrypt - why 32 bit o_len differs?
</pre>

<p>
<img src="Lenovo_X230_i5_4G/o_len/olen_time.png" border="0">
<br><br><i>Figure 6: Test 4 –  Impact of output length to run time</i>
</p>

</body>
</html>
