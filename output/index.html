<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title>Trivial PHC candidates tests</title>
</head>
<style>@media print { .pagebreak { page-break-before: always; } }</style>
<body>
<h1>Trivial PHC candidates (parameters) test</h1>

<p><b>Milan Broz &lt;gmazyland@gmail.com&gt;</b></p>

<i>
<p>v0 2014-11-10 Initial version</p>
<p>v1 2014-11-17 Added Gambit test, fixed Catena limits, update conclusion notes.</p>
</i>

<h3>PHS() API</h3>
<p>All PHC candidates provide API function</p>
<pre>
int PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost); 
</pre>

<p>The following tests tries to do simple operations using this provided function.</p>

<p>The candidate functions do not implement the API parameters
consistently.<br>Some functions implement only one of the cost
parameters (memory or time) and the scale differs significantly.
</p>
<p>The following tests take the password hash function as a
black-box,<br>supposing that invalid or unsupported parameters
combination is detected and function returns an error.<br>
(Which is not always true, unfortunately.)
</p>
<p>The tests always use one input parameter as a variable and
measure run time and/or memory consumption.</p>

<h3>Test vectors</h3>
I tried to reuse generated test vectors (including format) from
<a href="https://github.com/waywardgeek/PHC">previous test run by Bill Cox</a>,<br>
unfortunately not all files are usable (there are some modifications in algorithms<br>
and some vectors are not correct.)<br>

<h3>Test description</h3>
<p>Variable mcost/t_cost tests use special utility which measures difference in used memory using
<i>getrusage()</i> system call and<br>
run time using <i>clock_gettime(CLOCK_MONOTONIC)</i>.</p>
<p>The test run as special forked process started for each test separately.</p>
<p>The tests are repeated for 3 times and arithmetic mean of measurements is used.</p>

<p>Also I run simple dieharder randomness test and portability test
(compile and run test vectors on big endian Sparc architecture).</p>

<p>Because most of the algoritmhs are in reference version without
optimization, performance comparisons do not make sense.</p>
<p>The intention of tests it to compare limits and generic behaviour of algorithms.</p>

<h3>Code repository</h3>
<p>The repository copies submitted source code of PHC algoritms and compiles static library
for each algorithm.</p>
<p>All changes to submitted code are tracked by quilt, see <i>patches</i> subdirectory
in git (separate for every algorithm).
<br>(Changes includes only makefile modification for library build fixes, if neccessary.)</p>

<p>All code and output is on GitHub - <a href="https://github.com/mbroz/PHCtest">https://github.com/mbroz/PHCtest</a>.</p>

<h3>Algorithms</h3>
<p>Included are all submitted algoritms, except PolyPassHash (cannot be tested this way).</p>
<p>I added also Catena2 and RIG2 as were sent to mailing list.</p>
<p>Algorithms are in default (if possible reference) configurations.
(See <a href="https://github.com/mbroz/PHCtest">source code</a> for more details.)</p>
<p>Graphs are generated by Gnuplot.
<h3>Internal / detected algorithm limits:</h3>
Some algorithms do have strict limits but not all returns proper error on PHS() call.<br>
The following table is partial list of limits which were detected in these tests.<br>
<pre>
            plen min plen max out len min out len max mcost min mcost max tcost min tcost max
           |        |        |           |           |         |         |         |         |
Antcrypt   |   0    |  239   |     1     |           |    0    |         |    0    |         |
Argon      |   0    |  256   |     1     |    32     |    0    |         |    1    |         |
battcrypt  |   0    |        |     1     |    64     |    0    |         |    0    |         |
Catena     |   0    |        |     1     |    64     |   18    |   63    |    1    |         |
Catena2-BRG|   0    |        |     1     |    64     |    1    |         |    1    |         |
Catena2-DBG|   0    |        |     1     |    64     |    1    |         |    1    |         |
Centrifuge |   0    |        |     1     |           |    0    |   63    |    0    |   63    |
EARWORM    |   0    |        |     1     |           |    0    |         |    1    |         |
Gambit     |   0    |  151   |     1     |   168     |    1    |         |    1    |         |
Lanarea    |   1    |        |      mult 32          |    1    |         |    1    |         |
Lyra2      |   0    |        |     1     |   191     |    4    |         |    0    |         |
Makwa      |   0    |        |     1     |           |    0    |         |    0    |         |
MCS_PHS    |   1    |  238   |     4     |    64     |    0    |         |    0    |         |
OmegaCrypt |   0    |  255   |      16,20,28,32,64   |    0    |         |    0    |         |
Parallel   |   0    |        |     1     |    64     |    0    |         |    0    |  106    |
POMELO     |   0    |        |     1     |   128     |    0    |         |    0    |         |
Pufferfish |   0    |        |     1     |           |    0    |         |    0    |         |
RIG        |   0    |        |     1     |   64      |    1    |         |    1    |         |
RIG2       |   0    |        |     1     |   64      |    1    |         |    1    |         |
Schvrch    |   0    |        |     1     |           |    0    |         |    0    |         |
Tortuga    |   0    |        |     1     |           |    0    |         |    0    |         |
TwoCats    |   0    |        |    32     |    32     |    0    |         |    0    |         |
Yarn       |   0    |        |     1     |    64     |    0    |         |    0    |         |
yescrypt   |   0    |        |    32     |    32     |    0    |         |    0    |         |
</pre>

<p>Tests 1 and 3-6 are run on Lenovo X230 notebook / i5 CPU / 4GB memory</p>
<p>Test 2 is run on dual CPU Sparc64, 8GB memory.</p>

<hr>

<h1>Test 1. Dieharder test</h1>

<p>The output of hashing functions should pass basic randomness tests.<br>
Fail in these tests indicates some internal problem. (While passing tests indicate in fact nothing:-)</p>
<p>The test generates 32bytes hashes of consencutive little endian integer (4 bytes) with fixed
16 byte salt.<br>Output is written into file (for time reasons the file size is limited to 400MB).</p>
<p>All algoritms uses minimal values of m_cost and t_cost.</p>
<p>The dieharder testsuite is run with file input generator (dieharder -a -f file -g 201).</p>
<h3>Fixes</h3>
<p>
<li>fixed pufferfish PHS output to raw mode (default output is converted to hex64 encoding which is apparently not random)</li>
<li>Catena m_cost limitation caused by fixed MIN_GARLIC was removed (otherwise genrating 400MB will take more than week)</li>
</p>
<h3>Output</h3>
<p>The only completely failed output is for Tortuga (author already mentioned problem
<a href="http://comments.gmane.org/gmane.comp.security.phc/1583">here</a>).</p>
<p>There is a lot of minor fails for rgb_lagged_sum and marsaglia_tsang_gcd test but because
the input file is quite small,<br>these failures are probably not important.</p>
<p>The full test output <a href="https://github.com/mbroz/PHCtest/tree/master/output/Dieharder">is here</a>.</p>

<h1>Test 2. Portability test</h1>

<p>As a simple code portability test I tried to run test vectors on completely different architecture,
<br>namely on Sparc64 (with 32bit userspace) (Debian distro, Big Endian, 8Kb page size).</p>
<h3>Compilation fixes</h3>
<p>
  <li>removed -march=native (not supported)</li>
  <li>removed Intel only -mmmx -msse -msse2 -msse3 -msse4 -maes -mavx switches (not supported)</li>
  <li>BLAKE2 replaced with reference implementation (optimised code requires SSE at least)</li>
  <li>used 32bit compilation switches where required</li>
</p>
<p>The patch for Makefiles and run output <a href="https://github.com/mbroz/PHCtest/tree/master/output/Sparc/">is here</a>
(BLAKE2 reference code replacement not included in patch).</p>

<h3>Test vectors</h3>
<p>I run test vectors (all of them passed on x86_64)</p>
<p><b>PASSED:</b> battcrypt, catena, catena2-brg, catena2-dbg, makwa, mcs_phs, parallel, tortuga, yarn, yescrypt</p>
<p><b>CRASHED:</b> earworm (segfault), twocats (Bus error)</p>
<p><b>FAILED vectors:</b> antcrypt, argon, centrifuge, gambit, lanarea, lyra2, omegacrypt, pomelo, pufferfish, rig, rig2, schvrch</p>

<h1>Test 3. Variable memory cost</h1>

<p>The goal is to verify and compare real used memory according
to memory cost parameter.<br>
Test also compares impact to run time (large used memory accesses are
expensive).</p>
<p>Test increases mcost according to following table and measures used memory and run time.</p>
<p>Other parameters are fixed as below.</p>
<pre>
salt 16 bytes
input 32 bytes
output 32 bytes

           |mcost_min|mcost_step|mcost_max|tcost |
antcrypt   |   0     |     1    |     17  |   0  |
argon      |   0     |   100    |   8000  |   0  |
battcrypt  |   0     |     1    |     16  |   0  |
catena     |   0     |     1    |     25  |   1  |
catena2-dbg|   0     |     1    |     25  |   1  |
catena2-brg|   0     |     1    |     25  |   1  |
centrifuge |   0     |     1    |     23  |   0  |
earworm    |   0     |     1    |     19  |   1  |
gambit     |   1     | 10000    |1000001  |100000|
lanarea    |   0     |    10    |    300  |   1  |
lyra2      |   0     |   200    |  10000  |   1  |
makwa      | N/A -  mcost unused                 |
mcs_phs    | N/A - cost/memory dependent         |
omegacrypt |   0     |     1    |     11  |   0  |
parallel   | N/A -  mcost unused                 |
pomelo     |   0     |     1    |     17  |   0  |
pufferfish |   0     |     1    |     15  |   0  |
rig        |   0     |     1    |     17  |   1  |
rig2       |   0     |     1    |     17  |   1  |
schvrch    |   0     |  1000    |  50000  |   0  |
tortuga    |   0     | 10000    |1048575  |   0  |
twocats    |   0     |     1    |     20  |   0  |
yarn       |   0     |     1    |     25  |   0  |
yescrypt   |   0     |     1    |     20  |   0  |
</pre>

<span class="pagebreak"></span>
<p>
<img src="Lenovo_X230_i5_4G/m_cost/mcost_memory.png" border="0">
<br><br><i>Figure 1: Test 3 –  Variable memory cost (impact to memory use)</i>
</p>

<p>
<img src="Lenovo_X230_i5_4G/m_cost/mcost_time.png" border="0">
<br><br><i>Figure 2: Test 3 – Variable memory cost (impact to run time)</i>
</p>

<span class="pagebreak"></span>

<h1>Test 4. Variable time cost</h1>

<p>The goal is to verify and compare run time according to time cost parameter.<br>
Test also compares impact to used memory (in theory there shouldn't be
significant increase).</p>

<p>Test increases tcost according to following table and measures used memory and run time.</p>
<p>Other parameters are fixed as below.</p>
<pre>
salt 16 bytes
input 32 bytes
output 32 bytes

           |tcost_min|tcost_step|tcost_max| mcost |
antcrypt   |   0     |     1    |      30 |    10 |
argon      |   0     |    10    |     300 |   500 |
battcrypt  |   0     |     1    |      20 |     5 |
catena     |   0     |     5    |     100 |    18 |
catena2-brg|   0     |     5    |     100 |    14 |
catena2-dbg|   0     |     5    |     100 |    14 |
centrifuge |   0     |     1    |      28 |     0 |
earworm    |   0     |   500    |   20000 |    10 |
gambit     |   1     |  2000    |  400000 |     1 |
lanarea    |   0     |     1    |       8 |   150 |
lyra2      |   0     |  1000    |   20000 |   100 |
makwa      |   0     | 10000    |  300000 |     0 |
mcs_phs    | N/A - cost/memory dependent          |
omegacrypt |   0     |     1    |       9 |     2 |
parallel   |   0     |     1    |      26 |     0 |
pomelo     |   0     |     1    |      15 |     5 |
pufferfish |   0     |     1    |       9 |    10 |
rig        |   0     |  1000    |   20000 |     5 |
rig2       |   0     |  1000    |   20000 |     5 |
schvrch    |   0     |  2000    |  200000 |  1000 |
tortuga    |   0     | 10000    | 1048575 |100000 |
twocats    |   0     |     1    |      20 |     7 |
yarn       |   0     |100000    |10000000 |    15 |
yescrypt   |   0     |    10    |     300 |    10 |
</pre>

<span class="pagebreak"></span>
<p>
<img src="Lenovo_X230_i5_4G/t_cost/tcost_memory.png" border="0">
<br><br><i>Figure 3: Test 4 –  Variable time cost (impact to memory use)</i>
</p>

<p>
<img src="Lenovo_X230_i5_4G/t_cost/tcost_time.png" border="0">
<br><br><i>Figure 4: Test 4 –  Variable time cost (impact to run time)</i>
</p>

<span class="pagebreak"></span>

<h1>Test 5. Impact of input length to run time (with fixed costs).</h1>

<p>The test should illustrate that run time is not dependent on input length.</p>

<p>The input is random password increased from 1 to 300 bytes.</p>
<p>Other parameters are fixed as below (mcost and tcost chosen to be minimal,
just to provide run time aroung 50ms on the particular machine).</p>
<pre>
salt 16 bytes
output 32 bytes
input 1 - 300, step 1 bytes

           | mcost| tcost|
antcrypt   |    0 |   800|
argon      |    0 |  2000|
battcrypt  |    0 |    17|
catena     |   14 |    10|
catena2-brg|   14 |    10|
catena2-dbg|   10 |    10|
centrifuge |    0 |    21|
earworm    |    0 |  1000|
gambit     |30001 | 30001|
lanarea    |    1 |   600|
lyra2      |    3 | 10000|
makwa      |    0 | 30000|
mcs_phs    |    0 | 30000|
omegacrypt |    0 |     1|
parallel   |    0 |    11|
pomelo     |    0 |    13|
pufferfish |    0 |    12|
rig        |    1 |500000|
rig2       |    1 |  3000|
schvrch    |    0 | 12000|
tortuga    |    0 | 80000|
twocats    |    7 |    12|
yarn       |    0 |500000|
yescrypt   |   10 |    10|
</pre>

<p>
<img src="Lenovo_X230_i5_4G/i_len/ilen_time.png" border="0">
<br><br><i>Figure 5: Test 5 –  Impact of input length to run time</i>
</p>

<span class="pagebreak"></span>

<h1>Test 6. Impact of output lengths to run time (with fixed costs).</h1>

<p>The test should illustrate that run time is not dependent on output length.</p>

<p>The output is increased from 1 to 300 bytes.</p>
<p>Other parameters are fixed as below (mcost and tcost chosen to be minimal,
just to provide run time aroung 50ms on the particular machine).</p>

<pre>
salt 16 bytes
intput 32 bytes
output 1 - 300, step 1 bytes

mcost and tcose - same as in previous test
</pre>

<p>
<img src="Lenovo_X230_i5_4G/o_len/olen_time.png" border="0">
<br><br><i>Figure 6: Test 6 –  Impact of output length to run time</i>
</p>

<span class="pagebreak"></span>

<h1>Conclusion</h1>

<p>The tests were formerly intended as comparison of PHC candidated in KDF mode<br>
(for potential future use in <a href="https://code.google.com/p/cryptsetup/">cryptsetup/LUKS</a> full-disk encryption system).</p>
<p>The tests independently extends some tests run by Bill Cox (and try to reuse some test vectors).</p>
<p>The only common interface is required PHS() function so I tried to at least visualize canditates this way.</p>
<h3>Found problems</h3>

<p>The code of many candidates is not portable (as was seen by failing test vectors generated on Intel architecture).</p>

<p>This is probably not issue for the first round but from the engineering point of view next round should provide also portable code variant.
<br>While the most used architecture is x86_64 and optimizing it
there is important, for project like cryptsetup is very important<br>that all supported architectures can use the same algorithms
(Intel, ARM32/64, PowePC, S390, Sparc, etc).<br>Reference code probably should not rely on Intel only extensions.</p>
<p>Just for the reference, <a href="https://github.com/mbroz/PHCtest/blob/master/output/Sparc/git-diff.patch ">this patch</a>
was required to fix compilation on Sparc architecture.<br>
And <a href="https://github.com/mbroz/PHCtest/blob/master/output/Sparc/run_vectors.log">this was the output</a> of run_vectors script...</p>

<p>The Pufferfish PHS() API <a href="https://github.com/mbroz/PHCtest/blob/master/hash_libs/pufferfish/patches/fix-raw-output.patch">has to be fixed</a>
to produce proper raw output.</p>

<p><b>The Dieharder tests</b> found nothing new, Tortuga algorithm <a href="http://comments.gmane.org/gmane.comp.security.phc/1583">has known weaknesses</a>
(and there is no new version AFAIK).<p>
<p>The Pufferfish mistake in submitted PHS() implementation (which includes even buffer overflow) just underlines that these
trivial tests<br>could be useful to find serious problems.</p>

<p>From the <b>variable parameter run test</b> is interesting that
<ul>
<li>Centrifuge implementation cannot increase t_cost independently of m_cost, which could cause problems on systems with limited memory.</li>
<li>All other algoritms seems to keep memory usage quite constant while increasing t_cost.</li>
<li>The MCS_PHS has dependent m_cost and t_const parameters, so testing variable parameters don't make much sense.</li>
<li>The variable m_cost test for Makwa and Parallel make no sense because m_cost parameter is intentionally unused.</li>
</ul>
</p>

<p>The <b>variable input/output length tests</b> seems to show that
<ul>
<li>EARWORM run time increases with both input and output length.</li>
<li>There is a very strong run time dependence on output length for MCS_PHS.</li>
<li>Argon seems to support only maximal of 32 bytes hash output but <a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/o_len/argon.dat">
API does not prevent generation of longer hashes</a> and output hash contain non-random sequence.</li>
<li>Argon also supports <a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/i_len/argon.dat">only maximal 256 characters input</a>,
ignoring longer hashes without error (and producing the same hash).</li>

<li><s>All Catena variants
(<a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/o_len/catena.dat">Catena</a>,
<a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/o_len/catena2-brg.dat">Catena2-BRG</a>,
<a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/o_len/catena2-dbg.dat">Catena2-DBG</a>)
API wrongly produces hash if output length is greater than 256 bytes.
</s><br>[v1: fixed by patch from upstream git]</li>
<li>Lanarea produces only <a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/o_len/catena2-dbg.dat">multiple of 32 bytes hash outputs</a>
but because hash is only shortened to expected length it is superfluous limitation.</li>
<li>Yescrypt seems to produce <a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/o_len/yescrypt.dat">
different output for 32 bytes</a> hash than for all other combinations.<br>
[v1: The 32 bytes hash is a special case for server relief,
<a href="http://permalink.gmane.org/gmane.comp.security.phc/2238">more info here</a>].</li>
<li>Lyra2 crashes (segfault) if requested output hash size is longer than 191 bytes. [v1]</li>
</ul>
</p>

<p>The Antcrypt, Battcrypt, EARWORM, Gambit, Lanarea, Makwa, Parallel, Pufferfish, Tortuga and partially yescrypt hash calculation output
is independent of output length parameter (it affects only length written to output but not calculation).<br>
All other candidates will produce different hashes if output is shortened (IOW output 16 hash is not half of 32 bytes output).</p>

<p>Most of the problems are implementation details but probably should be fixed if candidates are selected for the next round.</p>
<hr>
<p>The more rigorous tests will be run with second round PHC candidates anyway.</p>
</body>
</html>
