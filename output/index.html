<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title>Trivial PHC candidates tests</title>
</head>
<style>@media print { .pagebreak { page-break-before: always; } }</style>
<body>
<h1>Trivial PHC candidates parameters test</h1>
<p>Milan Broz &lt;gmazyland@gmail.com&gt;</p>

<h3>PHS() API</h3>
<p>All PHC candidates provide API function</p>
<pre>
int PHS(void *out, size_t outlen, const void *in, size_t inlen, const void *salt, size_t saltlen, unsigned int t_cost, unsigned int m_cost); 
</pre>

<p>The following tests tries to do simple operations using this provided function.</p>

<p>The candidate functions do not implement the API parameters
consistently.<br>Some functions implement only one of the cost
parameters (memory or time) and the scale differs significantly.
</p>
<p>The following tests take the password hash function as a
black-box,<br>supposing that invalid or unsupported parameters
combination is detected and function returns an error.<br>
(Which is not always true, unfortunately.)
</p>
<p>The tests always use one input parameter as a variable and
measure run time and/or memory consumption.</p>

<h3>Test vectors</h3>
I tried to reuse generated test vectors (including format) from
<a href="https://github.com/waywardgeek/PHC">previous test run by Bill Cox</a>,<br>
unfortunately not all files are usable (there are some modifications in algorithms<br>
and some vectors are not correct.)<br>

<h3>Test description</h3>
<p>Variable mcost/t_cost tests use special utility which measures difference in used memory using
<i>getrusage()</i> system call and<br>
run time using <i>clock_gettime(CLOCK_MONOTONIC)</i>.</p>
<p>The test run as special forked process started for each test separately.</p>
<p>The tests are repeated for 3 times and arithmetic mean of measurements is used.</p>

<p>Also I run simple dieharder randomness test and portability test
(compile and run test vectors on big endian Sparc architecture).</p>

<p>Because most of the algoritmhs are in reference version without
optimization, performance comparisons do not make sense.</p>
<p>The intention of tests it to compare limits and generic behaviour of algorithms.</p>

<h3>Code repository</h3>
<p>The repository copies submitted source code of PHC algoritms and compiles static library
for each algorithm.</p>
<p>All changes to submitted code are tracked by quilt, see <i>patches</i> subdirectory
in git (separate for every algorithm).
<br>(Changes includes only makefile modification for library build fixes, if neccessary.)</p>

<p>All code and output is on GitHub - <a href="https://github.com/mbroz/PHCtest">https://github.com/mbroz/PHCtest</a>.</p>

<h3>Algorithms</h3>
<p>Included are all submitted algoritms, except PolyPassHash (cannot be tested this way).</p>
<p>I added also Catena2 and RIG2 as were sent to mailing list.</p>
<p>Algorithms are in default (if possible reference) configurations.
(See <a href="https://github.com/mbroz/PHCtest">source code</a> for more details.)</p>
<p>Graphs are generated by Gnuplot.
<h3>Internal / detected algorithm limits:</h3>
Some algorithms do have strict limits but not all returns proper error on PHS() call.<br>
The following table is partial list of limits which were detected in these tests.<br>
<pre>
            plen min plen max out len min out len max mcost min mcost max tcost min tcost max
           |        |        |           |           |         |         |         |         |
Antcrypt   |   0    |  239   |     1     |           |    0    |         |    0    |         |
Argon      |   0    |  256   |     1     |    32     |    0    |         |    1    |         |
battcrypt  |   0    |        |     1     |    64     |    0    |         |    0    |         |
Catena     |   0    |        |     1     |    64     |   18    |   63    |    0    |         |
Catena2-BRG|   0    |        |     1     |    64     |    0    |         |    0    |         |
Catena2-DBG|   0    |        |     1     |    64     |    1    |         |    0    |         |
Centrifuge |   0    |        |     1     |           |    0    |   63    |    0    |   63    |
EARWORM    |   0    |        |     1     |           |    0    |         |    1    |         |
Gambit     |   0    |  151   |     1     |           |    1    |         |    1    |         |
Lanarea    |   1    |        |      mult 32          |    1    |         |    1    |         |
Lyra2      |   0    |        |     1     |           |    4    |         |    0    |         |
Makwa      |   0    |        |     1     |           |    0    |         |    0    |         |
MCS_PHS    |   1    |  238   |     4     |    64     |    0    |         |    0    |         |
OmegaCrypt |   0    |  255   |      16,20,28,32,64   |    0    |         |    0    |         |
Parallel   |   0    |        |     1     |    64     |    0    |         |    0    |  106    |
POMELO     |   0    |        |     1     |   128     |    0    |         |    0    |         |
Pufferfish |   0    |        |     1     |           |    0    |         |    0    |         |
RIG        |   0    |        |     1     |   64      |    1    |         |    1    |         |
RIG2       |   0    |        |     1     |   64      |    1    |         |    1    |         |
Schvrch    |   0    |        |     1     |           |    0    |         |    0    |         |
Tortuga    |   0    |        |     1     |           |    0    |         |    0    |         |
TwoCats    |   0    |        |    32     |    32     |    0    |         |    0    |         |
Yarn       |   0    |        |     1     |    64     |    0    |         |    0    |         |
yescrypt   |   0    |        |    32     |    32     |    0    |         |    0    |         |
</pre>

<p>Tests 1 and 3-6 are run on Lenovo X230 notebook / i5 CPU / 4GB memory</p>
<p>Test 2 is run on dual CPU Sparc64, 8GB memory.</p>

<hr>

<h1>Test 1. Dieharder test</h1>

<p>The output of hashing functions should pass basic randomness tests.<br>
Fail in these tests indicates some internal problem. (While passing tests indicate in fact nothing:-)</p>
<p>The test generates 32bytes hashes of consencutive little endian integer (4 bytes) with fixed
16 byte salt.<br>Output is written into file (for time reasons the file size is limited to 400MB).</p>
<p>All algoritms uses minimal values of m_cost and t_cost.</p>
<p>The dieharder testsuite is run with file input generator (dieharder -a -f file -g 201).</p>
<h3>Fixes</h3>
<p>
<li>fixed pufferfish PHS output to raw mode (default output is converted to hex64 encoding which is apparently not random)</li>
<li>Catena m_cost limitation caused by fixed MIN_GARLIC was removed (otherwise genrating 400MB will take more than week)</li>
</p>
<h3>Output</h3>
<p>The only completely failed output is for Tortuga (author already mentioned problem
<a href="http://comments.gmane.org/gmane.comp.security.phc/1583">here</a>).</p>
<p>There is a lot of minor fails for rgb_lagged_sum and marsaglia_tsang_gcd test but because
the input file is quite small,<br>these failures are probably not important.</p>
<p>The full test output <a href="https://github.com/mbroz/PHCtest/output/Dieharder/">is here</a>.</p>

<h1>Test 2. Portability test</h1>

<p>As a simple code portability test I tried to run test vectors on completely different architecture,
<br>namely on Sparc64 (with 32bit userspace) (Debian distro, Big Endian, 8Kb page size).</p>
<h3>Compilation fixes</h3>
<p>
  <li>removed -march=native (not supported)</li>
  <li>removed Intel only -mmmx -msse -msse2 -msse3 -msse4 -maes -mavx switches (not supported)</li>
  <li>BLAKE2 replaced with reference implementation (optimised code requires SSE at least)</li>
  <li>used 32bit compilation switches where required</li>
</p>
<p>The patch for Makefiles and run output <a href="https://github.com/mbroz/PHCtest/output/Sparc/">is here</a>
(BLAKE2 reference code replacement not included in patch).</p>

<h3>Test vectors</h3>
<p>I run test vectors (all of them passed on x86_64)</p>
<p><b>PASSED:</b> battcrypt, catena, catena2-brg, catena2-dbg, makwa, mcs_phs, parallel, tortuga, yarn, yescrypt</p>
<p><b>CRASHED:</b> earworm (segfault), twocats (Bus error)</p>
<p><b>FAILED vectors:</b> antcrypt, argon, centrifuge, gambit, lanarea, lyra2, omegacrypt, pomelo, pufferfish, rig, rig2, schvrch</p>

<h1>Test 3. Variable memory cost</h1>

<p>The goal is to verify and compare real used memory according
to memory cost parameter.<br>
Test also compares impact to run time (large used memory accesses are
expensive).</p>
<p>Test increases mcost according to following table and measures used memory and run time.</p>
<p>Other parameters are fixed as below.</p>
<pre>
salt 16 bytes
input 32 bytes
output 32 bytes

           |mcost_min|mcost_step|mcost_max|tcost|
antcrypt   |   0     |     1    |     17  |   0 |
argon      |   0     |   100    |   8000  |   0 |
battcrypt  |   0     |     1    |     16  |   0 |
catena     |   0     |     1    |     25  |   0 |
catena2-dbg|   0     |     1    |     25  |   0 |
catena2-brg|   0     |     1    |     25  |   0 |
centrifuge |   0     |     1    |     23  |   0 |
earworm    |   0     |     1    |     19  |   1 |
gambit     | N/A - cost/memory dependent        |
lanarea    |   0     |    10    |    300  |   1 |
lyra2      |   0     |   200    |  10000  |   1 |
makwa      | N/A -  mcost unused                |
mcs_phs    | N/A - cost/memory dependent        |
omegacrypt |   0     |     1    |     11  |   0 |
parallel   | N/A -  mcost unused                |
pomelo     |   0     |     1    |     17  |   0 |
pufferfish |   0     |     1    |     15  |   0 |
rig        |   0     |     1    |     17  |   1 |
rig2       |   0     |     1    |     17  |   1 |
schvrch    |   0     |  1000    |  50000  |   0 |
tortuga    |   0     | 10000    |1048575  |   0 |
twocats    |   0     |     1    |     20  |   0 |
yarn       |   0     |     1    |     25  |   0 |
yescrypt   |   0     |     1    |     20  |   0 |
</pre>

<span class="pagebreak"></span>
<p>
<img src="Lenovo_X230_i5_4G/m_cost/mcost_memory.png" border="0">
<br><br><i>Figure 1: Test 3 –  Variable time cost (impact to memory use)</i>
</p>

<p>
<img src="Lenovo_X230_i5_4G/m_cost/mcost_time.png" border="0">
<br><br><i>Figure 2: Test 3 – Variable memory cost (impact to run time)</i>
</p>

<span class="pagebreak"></span>

<h1>Test 4. Variable time cost</h1>

<p>The goal is to verify and compare run time according to time cost parameter.<br>
Test also compares impact to used memory (in theory there shouldn't be
significant increase).</p>

<p>Test increases tcost according to following table and measures used memory and run time.</p>
<p>Other parameters are fixed as below.</p>
<pre>
salt 16 bytes
input 32 bytes
output 32 bytes

           |tcost_min|tcost_step|tcost_max| mcost |
antcrypt   |   0     |     1    |      30 |    10 |
argon      |   0     |    10    |     300 |   500 |
battcrypt  |   0     |     1    |      20 |     5 |
catena     |   0     |     5    |     100 |    18 |
catena2-brg|   0     |     5    |     100 |    14 |
catena2-dbg|   0     |     5    |     100 |    14 |
centrifuge |   0     |     1    |      28 |     0 |
earworm    |   0     |   500    |   20000 |    10 |
gambit     | N/A - cost/memory dependent          |
lanarea    |   0     |     1    |       8 |   150 |
lyra2      |   0     |  1000    |   20000 |   100 |
makwa      |   0     | 10000    |  300000 |     0 |
mcs_phs    | N/A - cost/memory dependent          |
omegacrypt |   0     |     1    |       9 |     2 |
parallel   |   0     |     1    |      26 |     0 |
pomelo     |   0     |     1    |      15 |     5 |
pufferfish |   0     |     1    |       9 |    10 |
rig        |   0     |  1000    |   20000 |     5 |
rig2       |   0     |  1000    |   20000 |     5 |
schvrch    |   0     |  2000    |  200000 |  1000 |
tortuga    |   0     | 10000    | 1048575 |100000 |
twocats    |   0     |     1    |      20 |     7 |
yarn       |   0     |100000    |10000000 |    15 |
yescrypt   |   0     |    10    |     300 |    10 |
</pre>

<span class="pagebreak"></span>
<p>
<img src="Lenovo_X230_i5_4G/t_cost/tcost_memory.png" border="0">
<br><br><i>Figure 3: Test 4 –  Variable time cost (impact to memory use)</i>
</p>

<p>
<img src="Lenovo_X230_i5_4G/t_cost/tcost_time.png" border="0">
<br><br><i>Figure 4: Test 4 –  Variable time cost (impact to run time)</i>
</p>

<span class="pagebreak"></span>

<h1>Test 5. Impact of input length to run time (with fixed costs).</h1>

<p>The test should illustrate that run time is not dependent on input length.</p>

<p>The input is random password increased from 1 to 300 bytes.</p>
<p>Other parameters are fixed as below (mcost and tcost chosen to be minimal,
just to provide run time aroung 50ms on the particular machine).</p>
<pre>
salt 16 bytes
output 32 bytes
input 1 - 300, step 1 bytes

           | mcost| tcost|
antcrypt   |    0 |   800|
argon      |    0 |  2000|
battcrypt  |    0 |    17|
catena     |   18 |     0|
catena2-brg|   14 |    10|
catena2-dbg|   10 |    10|
centrifuge |    0 |    21|
earworm    |    0 |  1000|
gambit     |30001 | 30001|
lanarea    |    1 |   600|
lyra2      |    3 | 10000|
makwa      |    0 | 30000|
mcs_phs    |    0 | 30000|
omegacrypt |    0 |     1|
parallel   |    0 |    11|
pomelo     |    0 |    13|
pufferfish |    0 |    12|
rig        |    1 |500000|
rig2       |    1 |  3000|
schvrch    |    0 | 12000|
tortuga    |    0 | 80000|
twocats    |    7 |    12|
yarn       |    0 |500000|
yescrypt   |   10 |    10|
</pre>

<p>
<img src="Lenovo_X230_i5_4G/i_len/ilen_time.png" border="0">
<br><br><i>Figure 5: Test 5 –  Impact of input length to run time</i>
</p>

<span class="pagebreak"></span>

<h1>Test 6. Impact of output lengths to run time (with fixed costs).</h1>

<p>The test should illustrate that run time is not dependent on output length.</p>

<p>The output is increased from 1 to 300 bytes.</p>
<p>Other parameters are fixed as below (mcost and tcost chosen to be minimal,
just to provide run time aroung 50ms on the particular machine).</p>

<pre>
salt 16 bytes
intput 32 bytes
output 1 - 300, step 1 bytes

mcost and tcose - same as in previous test
</pre>

<p>
<img src="Lenovo_X230_i5_4G/o_len/olen_time.png" border="0">
<br><br><i>Figure 6: Test 6 –  Impact of output length to run time</i>
</p>

<span class="pagebreak"></span>

<h1>Conclusion</h1>

<p>The tests were formerly intended as comparison of PHC candidated in KDF mode<br>
(for potential future use in <a href="https://code.google.com/p/cryptsetup/">cryptsetup/LUKS</a> full-disk encryption system).</p>
<p>But because the only common interface is required PHS() function, I tried to at least visualize canditates this way.</p>
<p>The tests independently extends some tests run by Bill Cox (and try to reuse some test vectors).</p>
<h3>Found problems</h3>

<p>The code of many candidates is not portable (as was seen by failing test vectors generated on Intel architecture).</p>

<p>This is probably not issue for the first round but from the engineering point of view next round should provide also portable code variant.
<br>While the most used architecture is x86_64 and optimizing it
there is important, for project like cryptsetup is very important<br>that all supported architectures can use the same algorithms
(Intel, ARM32/64, PowePC, S390, Sparc, etc).<br>Reference code probably should not rely on Intel only extensions.</p>
<p>Just for the reference, <a href="https://github.com/mbroz/PHCtest/blob/master/sparc-compile/git-diff.patch ">this patch</a>
was required to fix compilation on Sparc architecture.<br>
And <a href="https://github.com/mbroz/PHCtest/blob/master/sparc-compile/run_vectors.log">this was the output</a> of run_vectors script...</p>

<p>The Pufferfish PHS() API <a href="https://github.com/mbroz/PHCtest/blob/master/hash_libs/pufferfish/patches/fix-raw-output.patch">has to be fixed</a>
to produce proper raw output.</p>

<p><b>The Dieharder tests</b> found nothing new, Tortuga algorithm <a href="http://comments.gmane.org/gmane.comp.security.phc/1583">has known weaknesses</a>
(and there is no new version AFAIK).<p>
<p>The Pufferfish mistake in PHS() implementation (which includes even buffer overflow) just underlines that these
trivial tests<br>could be useful to find serious problems.</p>

<p>From the <b>variable parameter run test</b> is interesting that
<ul>
<li>Centrifuge implementation cannot increase t_cost independently of m_cost, which could cause problems on systems with limited memory.</li>
<li>All other algoritms seems to keep memory usage quite constant while increasing t_cost.</li>
<li>The Gambit and MCS_PHS have dependent m_cost and t_const parameters, so testing variable parameters don't make much sense.</li>
<li>The variable m_cost test for Makwa and Parallel make no sense because m_cost parameter is intentionally unused.</li>
</ul>
</p>

<p>The <b>variable input/output length tests</b> seems to show that
<ul>
<li>EARWORM run time increases with both input and output length.</li>
<li>there is a very strong run time dependence on output length for MCS_PHS.</li>
<li>Argon seems to support only maximal of 32 bytes hash output but <a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/o_len/argon.dat">
API does not prevent generation of longer hashes</a> and output hash contain non-random sequence.</li>
<li>Argon also supports <a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/i_len/argon.dat">only maximal 256 characters input</a>,
ignoring longer hashes without error (and producing the same hash).</li>
<li>All Catena variants
(<a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/o_len/catena.dat">Catena</a>,
<a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/o_len/catena2-brg.dat">Catena2-BRG</a>,
<a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/o_len/catena2-dbg.dat">Catena2-DBG</a>)
API wrongly produces hash if output length is greater than 256 bytes.</li>
<li>Lanarea produces only <a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/o_len/catena2-dbg.dat">multiple of 32 bytes hash outputs</a>
but because hash is only shortened to expected length it is superfluous limitation.</li>
<li>yescrypt seems to produce <a href="https://github.com/mbroz/PHCtest/blob/master/output/Lenovo_X230_i5_4G/o_len/yescrypt.dat">
different output for 32 bytes</a> hash than for all other combinations.</li>
</ul>
</p>

<p>The Antcrypt, Battcrypt, EARWORM, Gambit, Lanarea, Makwa, Parallel, Pufferfish, Tortuga and partially yescrypt hash calculation output
is independent<br>of output length parameter (it affects only length written to output but not calculation).<br>
All other candidates will produce different hashes if output is shortened (IOW output 16 hash is not half of 32 bytes output).</p>

<p>Most of the problems are implementation details but probably should be fixed if candidates are selected for the next round.</p>
<hr>
<p>The more rigorous tests will be run with second round PHC candidates anyway.</p>
</body>
</html>
